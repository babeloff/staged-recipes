# yaml-language-server: $schema=https://raw.githubusercontent.com/prefix-dev/recipe-format/main/schema.json

context:
  name: hydra-scala
  version: "0.12.0"

package:
  name: ${{ name }}
  version: ${{ version }}

source:
  url: https://github.com/CategoricalData/hydra/archive/refs/heads/main.tar.gz
  sha256: 752943ededc55cb19c944a57b1f31788cc98ea9865b097a4f317af6f72c412c1

build:
  number: 0
  script:
    interpreter: nushell
    content: |
      # Build the Scala package using SBT
      cd ($env.SRC_DIR | path join "hydra-scala")

      # Update SBT version to be compatible with available conda-forge version
      # The upstream uses 1.5.5 but we need 1.6+ for better Java compatibility
      if ("project/build.properties" | path exists) {
        "sbt.version=1.6.2" | save --force "project/build.properties"
      }

      # Set JVM arguments to help with module system compatibility
      $env.SBT_OPTS = "--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED"

      # Display Java and SBT versions for debugging
      print "Java version:"
      ^java -version
      print "SBT version:"
      ^sbt --version

      # Build the project with verbose output
      print "Running SBT clean compile..."
      ^sbt -v clean compile

      # Package the project
      print "Running SBT package..."
      ^sbt -v package

      # Create installation directories
      mkdir ($env.PREFIX | path join "lib" "hydra-scala")
      mkdir ($env.PREFIX | path join "bin")

      # Copy built JAR files
      glob "target/**/*.jar" | each { |jar|
        cp $jar ($env.PREFIX | path join "lib" "hydra-scala")
      }

      # Copy dependencies
      try {
        ^sbt "export runtime:dependencyClasspath" | save deps.txt

        if ("deps.txt" | path exists) {
          open deps.txt | lines | each { |line|
            $line | parse --regex '(/[^:]*\.jar)' | each { |match|
              let jar_path = $match.capture0
              if ($jar_path | path exists) {
                cp $jar_path ($env.PREFIX | path join "lib" "hydra-scala")
              }
            }
          }
        }
      } catch {
        print "Warning: Could not export dependencies"
      }

      # Copy and install the wrapper script
      match ($nu.os-info.family) {
        "unix" => {
          cp ($env.RECIPE_DIR | path join "wrapper.sh") ($env.PREFIX | path join "bin" "hydra-scala")
          ^chmod +x ($env.PREFIX | path join "bin" "hydra-scala")
        }
        "windows" => {
          cp ($env.RECIPE_DIR | path join "wrapper.bat") ($env.PREFIX | path join "Scripts" "hydra-scala.bat")
        }
      }

      # Copy license and documentation
      if ("README.md" | path exists) { cp README.md $env.PREFIX }

      # Copy build configuration
      if ("build.sbt" | path exists) { cp build.sbt ($env.PREFIX | path join "lib" "hydra-scala") }

requirements:
  build:
    - openjdk >=11,<12
    - sbt >=1.6,<2.0
    - nushell
  host:
    - openjdk >=11,<12
    - sbt >=1.6,<2.0
  run:
    - openjdk >=11,<12

tests:
  - package_contents:
      files:
        - bin/hydra-scala
  - script: test_hydra_diagnostic.py
    requirements:
      build:
        - python >=3.8
        - openjdk >=11,<12
      run:
        - python >=3.8
        - openjdk >=11,<12

about:
  homepage: https://github.com/CategoricalData/hydra
  license: Apache-2.0
  license_file: LICENSE
  summary: Hydra Scala implementation - type-safe transformations for data and programs
  description: |
    Hydra is a domain-specific language for data models and data transformations.
    It is based on a typed lambda calculus, and transforms data and schemas between
    languages in a way which maintains type conformance. This package contains the
    Scala implementation of Hydra.
  repository: https://github.com/CategoricalData/hydra
  documentation: https://github.com/CategoricalData/hydra/tree/main/hydra-scala

extra:
  recipe-maintainers:
    - joshsh
